import { beforeEach, describe, expect, it } from "vitest";
import type {
  JournalEntry,
  JournalSummary,
  SummaryConfig,
} from "./journal.types";
import {
  AISummaryError,
  type AISummaryPort,
  type MoodAnalysis,
  MockAISummaryPort,
  SummaryPromptBuilder,
  type ThemeAnalysis,
  validateSummaryConfig,
} from "./ai-summary.port";

describe("AISummaryPort", () => {
  let mockPort: MockAISummaryPort;
  let sampleEntry: JournalEntry;
  let sampleConfig: SummaryConfig;

  beforeEach(() => {
    mockPort = new MockAISummaryPort();

    sampleEntry = {
      id: "journal-1",
      userId: "user-1",
      date: "2025-08-13",
      status: "completed",
      content: '{"type":"doc","content":[]}',
      plainTextContent:
        "Today was an amazing workout day! I felt so motivated and strong.",
      wordCount: 12,
      tags: ["fitness", "motivation"],
      createdAt: new Date("2025-08-13T10:00:00Z"),
      updatedAt: new Date("2025-08-13T10:30:00Z"),
    };

    sampleConfig = {
      provider: "openai",
      model: "gpt-4o-mini",
      maxTokens: 500,
      temperature: 0.3,
      enableMoodDetection: true,
      enableThemeClassification: true,
      enableInsightsGeneration: true,
    };
  });

  describe("MockAISummaryPort", () => {
    it("should implement AISummaryPort interface", () => {
      expect(mockPort).toHaveProperty("generateSummary");
      expect(mockPort).toHaveProperty("extractMood");
      expect(mockPort).toHaveProperty("classifyThemes");
      expect(mockPort).toHaveProperty("generateInsights");
      expect(mockPort).toHaveProperty("calculateSentiment");
      expect(mockPort).toHaveProperty("isHealthy");
      expect(mockPort).toHaveProperty("getSupportedLanguages");
      expect(mockPort).toHaveProperty("getMaxTextLength");
    });

    it("should generate default mock summary when no custom response set", async () => {
      const result = await mockPort.generateSummary(sampleEntry, sampleConfig);

      expect(result.id).toBe("summary-journal-1");
      expect(result.journalEntryId).toBe("journal-1");
      expect(result.summary).toBe(
        "Mock AI-generated summary of the journal entry.",
      );
      expect(result.keyTopics).toEqual(["mock", "topic"]);
      expect(result.mood).toBe("neutral");
      expect(result.themes).toEqual(["general"]);
      expect(result.insights).toEqual(["Mock insight generated by AI"]);
      expect(result.sentimentScore).toBe(0.0);
      expect(result.processingTime).toBe(500);
      expect(result.createdAt).toBeInstanceOf(Date);
    });

    it("should return custom mock summary when set", async () => {
      const customSummary: JournalSummary = {
        id: "custom-summary",
        journalEntryId: "journal-1",
        summary: "User had an excellent workout session with high motivation.",
        keyTopics: ["workout", "motivation", "strength"],
        mood: "excited",
        themes: ["workout", "motivation"],
        insights: [
          "Strong positive attitude towards fitness",
          "Consistent motivation levels",
        ],
        sentimentScore: 0.8,
        processingTime: 750,
        createdAt: new Date("2025-08-13T10:05:00Z"),
      };

      mockPort.setMockSummary(sampleEntry.plainTextContent, customSummary);
      const result = await mockPort.generateSummary(sampleEntry, sampleConfig);

      expect(result).toEqual(customSummary);
    });

    it("should extract mood analysis", async () => {
      const result = await mockPort.extractMood(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result.mood).toBe("neutral");
      expect(result.confidence).toBe(0.85);
      expect(result.alternatives).toHaveLength(1);
      expect(result.alternatives[0].mood).toBe("content");
      expect(result.alternatives[0].confidence).toBe(0.15);
    });

    it("should return custom mood analysis when set", async () => {
      const customMood: MoodAnalysis = {
        mood: "excited",
        confidence: 0.92,
        alternatives: [
          { mood: "happy", confidence: 0.75 },
          { mood: "determined", confidence: 0.68 },
        ],
      };

      mockPort.setMockMood(sampleEntry.plainTextContent, customMood);
      const result = await mockPort.extractMood(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toEqual(customMood);
    });

    it("should classify themes in text", async () => {
      const result = await mockPort.classifyThemes(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result.themes).toEqual(["general"]);
      expect(result.confidence).toBe(0.8);
      expect(result.themeScores).toHaveLength(2);
      expect(result.themeScores[0].theme).toBe("general");
      expect(result.themeScores[0].score).toBe(0.8);
    });

    it("should return custom theme analysis when set", async () => {
      const customThemes: ThemeAnalysis = {
        themes: ["workout", "motivation"],
        confidence: 0.94,
        themeScores: [
          { theme: "workout", score: 0.94 },
          { theme: "motivation", score: 0.87 },
          { theme: "progress", score: 0.23 },
        ],
      };

      mockPort.setMockThemes(sampleEntry.plainTextContent, customThemes);
      const result = await mockPort.classifyThemes(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toEqual(customThemes);
    });

    it("should generate insights", async () => {
      const result = await mockPort.generateInsights(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toEqual(["Mock insight about the journal content"]);
    });

    it("should return custom insights when set", async () => {
      const customInsights = [
        "Strong commitment to fitness goals",
        "Positive mindset towards challenges",
        "Consistent motivation patterns",
      ];

      mockPort.setMockInsights(sampleEntry.plainTextContent, customInsights);
      const result = await mockPort.generateInsights(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toEqual(customInsights);
    });

    it("should calculate sentiment score", async () => {
      const result = await mockPort.calculateSentiment(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toBe(0.0);
    });

    it("should return custom sentiment when set", async () => {
      mockPort.setMockSentiment(sampleEntry.plainTextContent, 0.75);
      const result = await mockPort.calculateSentiment(
        sampleEntry.plainTextContent,
        sampleConfig,
      );

      expect(result).toBe(0.75);
    });

    it("should throw error when service is unhealthy", async () => {
      mockPort.setHealthy(false);

      await expect(
        mockPort.generateSummary(sampleEntry, sampleConfig),
      ).rejects.toThrow(AISummaryError);

      try {
        await mockPort.generateSummary(sampleEntry, sampleConfig);
      } catch (error) {
        expect(error).toBeInstanceOf(AISummaryError);
        const summaryError = error as AISummaryError;
        expect(summaryError.code).toBe("API_ERROR");
        expect(summaryError.retryable).toBe(true);
        expect(summaryError.message).toBe("Service unavailable");
      }
    });

    it("should report health status correctly", async () => {
      expect(await mockPort.isHealthy()).toBe(true);

      mockPort.setHealthy(false);
      expect(await mockPort.isHealthy()).toBe(false);

      mockPort.setHealthy(true);
      expect(await mockPort.isHealthy()).toBe(true);
    });

    it("should return supported languages", () => {
      const languages = mockPort.getSupportedLanguages();

      expect(languages).toContain("en");
      expect(languages).toContain("es");
      expect(languages).toContain("fr");
      expect(languages.length).toBeGreaterThan(5);
    });

    it("should return max text length constraint", () => {
      const maxLength = mockPort.getMaxTextLength();

      expect(maxLength).toBe(10000);
      expect(maxLength).toBeGreaterThan(0);
    });
  });

  describe("AISummaryError", () => {
    it("should create error with code and retryable flag", () => {
      const error = new AISummaryError("Text too long", "TEXT_TOO_LONG", false);

      expect(error.message).toBe("Text too long");
      expect(error.code).toBe("TEXT_TOO_LONG");
      expect(error.retryable).toBe(false);
      expect(error.name).toBe("AISummaryError");
      expect(error).toBeInstanceOf(Error);
    });

    it("should default retryable to false when not specified", () => {
      const error = new AISummaryError("API Error", "API_ERROR");

      expect(error.retryable).toBe(false);
    });

    it("should support all error codes", () => {
      const errorCodes = [
        "TEXT_TOO_LONG",
        "UNSUPPORTED_LANGUAGE",
        "API_ERROR",
        "TIMEOUT",
        "QUOTA_EXCEEDED",
        "CONTENT_FILTERED",
        "INVALID_REQUEST",
        "AUTHENTICATION_FAILED",
        "RATE_LIMITED",
        "MODEL_UNAVAILABLE",
      ] as const;

      errorCodes.forEach((code) => {
        const error = new AISummaryError(`Test ${code}`, code, true);
        expect(error.code).toBe(code);
        expect(error.retryable).toBe(true);
      });
    });
  });

  describe("validateSummaryConfig", () => {
    it("should validate correct configuration", () => {
      const result = validateSummaryConfig(sampleConfig);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
      expect(result.warnings).toHaveLength(0);
    });

    it("should reject invalid provider", () => {
      const invalidConfig = {
        ...sampleConfig,
        provider: "invalid-provider" as any,
      };

      const result = validateSummaryConfig(invalidConfig);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Invalid provider: invalid-provider");
    });

    it("should reject empty model", () => {
      const invalidConfig = {
        ...sampleConfig,
        model: "",
      };

      const result = validateSummaryConfig(invalidConfig);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Model is required");
    });

    it("should reject invalid max tokens", () => {
      const invalidConfig = {
        ...sampleConfig,
        maxTokens: 0,
      };

      const result = validateSummaryConfig(invalidConfig);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Max tokens must be greater than 0");
    });

    it("should warn about high token count", () => {
      const warnConfig = {
        ...sampleConfig,
        maxTokens: 5000,
      };

      const result = validateSummaryConfig(warnConfig);

      expect(result.isValid).toBe(true);
      expect(result.warnings).toContain("High token count may increase costs");
    });

    it("should reject invalid temperature", () => {
      const invalidConfig = {
        ...sampleConfig,
        temperature: -0.5,
      };

      const result = validateSummaryConfig(invalidConfig);

      expect(result.isValid).toBe(false);
      expect(result.errors).toContain("Temperature must be between 0 and 2");
    });

    it("should warn about high temperature", () => {
      const warnConfig = {
        ...sampleConfig,
        temperature: 1.5,
      };

      const result = validateSummaryConfig(warnConfig);

      expect(result.isValid).toBe(true);
      expect(result.warnings).toContain(
        "High temperature may produce less consistent results",
      );
    });
  });

  describe("SummaryPromptBuilder", () => {
    const sampleText = "Today was an amazing workout day!";

    it("should build comprehensive summary prompt", () => {
      const prompt = SummaryPromptBuilder.buildSummaryPrompt(sampleText, {
        includeKeyTopics: true,
        includeMood: true,
        includeThemes: true,
        includeInsights: true,
      });

      expect(prompt).toContain(sampleText);
      expect(prompt).toContain("brief summary");
      expect(prompt).toContain("Key topics");
      expect(prompt).toContain("Emotional mood");
      expect(prompt).toContain("Main themes");
      expect(prompt).toContain("Key insights");
      expect(prompt).toContain("JSON");
    });

    it("should build minimal summary prompt", () => {
      const prompt = SummaryPromptBuilder.buildSummaryPrompt(sampleText, {
        includeKeyTopics: false,
        includeMood: false,
        includeThemes: false,
        includeInsights: false,
      });

      expect(prompt).toContain(sampleText);
      expect(prompt).toContain("brief summary");
      expect(prompt).not.toContain("Key topics");
      expect(prompt).not.toContain("Emotional mood");
      expect(prompt).not.toContain("Main themes");
      expect(prompt).not.toContain("Key insights");
    });

    it("should build mood analysis prompt", () => {
      const prompt = SummaryPromptBuilder.buildMoodPrompt(sampleText);

      expect(prompt).toContain(sampleText);
      expect(prompt).toContain("emotional tone");
      expect(prompt).toContain("excited, happy, content");
      expect(prompt).toContain("JSON");
    });

    it("should build theme classification prompt", () => {
      const prompt = SummaryPromptBuilder.buildThemePrompt(sampleText);

      expect(prompt).toContain(sampleText);
      expect(prompt).toContain("main themes");
      expect(prompt).toContain("workout, nutrition, progress");
      expect(prompt).toContain("JSON");
    });

    it("should build sentiment analysis prompt", () => {
      const prompt = SummaryPromptBuilder.buildSentimentPrompt(sampleText);

      expect(prompt).toContain(sampleText);
      expect(prompt).toContain("sentiment");
      expect(prompt).toContain("-1");
      expect(prompt).toContain("+1");
      expect(prompt).toContain("JSON");
    });
  });

  describe("Contract verification", () => {
    it("should satisfy port interface contract", () => {
      const port: AISummaryPort = mockPort;

      expect(typeof port.generateSummary).toBe("function");
      expect(typeof port.extractMood).toBe("function");
      expect(typeof port.classifyThemes).toBe("function");
      expect(typeof port.generateInsights).toBe("function");
      expect(typeof port.calculateSentiment).toBe("function");
      expect(typeof port.isHealthy).toBe("function");
      expect(typeof port.getSupportedLanguages).toBe("function");
      expect(typeof port.getMaxTextLength).toBe("function");
    });

    it("should maintain type safety for generateSummary method", async () => {
      const result = await mockPort.generateSummary(sampleEntry, sampleConfig);

      expect(result).toHaveProperty("id");
      expect(result).toHaveProperty("journalEntryId");
      expect(result).toHaveProperty("summary");
      expect(result).toHaveProperty("keyTopics");
      expect(result).toHaveProperty("mood");
      expect(result).toHaveProperty("themes");
      expect(result).toHaveProperty("insights");
      expect(result).toHaveProperty("sentimentScore");
      expect(result).toHaveProperty("processingTime");
      expect(result).toHaveProperty("createdAt");

      expect(typeof result.id).toBe("string");
      expect(typeof result.journalEntryId).toBe("string");
      expect(typeof result.summary).toBe("string");
      expect(Array.isArray(result.keyTopics)).toBe(true);
      expect(typeof result.mood).toBe("string");
      expect(Array.isArray(result.themes)).toBe(true);
      expect(Array.isArray(result.insights)).toBe(true);
      expect(typeof result.sentimentScore).toBe("number");
      expect(typeof result.processingTime).toBe("number");
      expect(result.createdAt).toBeInstanceOf(Date);
    });
  });
});
